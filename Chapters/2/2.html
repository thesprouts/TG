<h1 id="feedback-growth-and-form">Feedback, Growth, and Form</h1>
<blockquote>
<p>We watch an ant make his laborious way across a wind- and wave-molded beach. He moves ahead, angles to the right to ease his climb up a steep dunelet, detours around a pebble, stops for a moment to exchange information with a compatriot. Thus he makes his weaving, halting way back home. . . . His horizons are very close, so that he deals with each obstacle as he comes to it; he probes for ways around or over it, without much thought for future obstacles. It is easy to trap him into deep detours.</p>
<p>Herbert Simon, <em>The Sciences of the Artificial</em></p>
</blockquote>
<p>Chapter 1 presented the rudiments of a computational view of geometry and introduced some themes-local versus global, intrinsic versus extrinsic, state, and fixed instruction programs — that will be important in chapters to come. The most important theme of all, however, is that turtle geometry is a mathematics designed for exploring. Now it’s time to explore. This chapter presents some ideas for using turtle graphics to investigate mathematics in an experimental and phenomenon-oriented way. Randomness, feedback systems, growth, differential games, and designs based on recursion are all fruitful areas. With the initiation provided here, we hope you will take the time to investigate some of these topics in depth.</p>
<h2 id="the-turtle-as-animal">The Turtle as Animal</h2>
<p>We introduced the turtle as a mathematical &quot;animal&quot;; let’s pursue that point of view by thinking of the turtle’s motion as a behavior pattern and the turtle programs as models of simple animal behavior. Turtle geometry is particularly well suited to such modeling because of the r local and intrinsic ways we specify the turtle’s movements. Expressing motions in terms of forwards and rights is a much more direct way of dealing with an animal’s behavior than, say, describing movements in response to stimuli as changes in <em>x</em> and <em>y</em> coordinates.</p>
<div class="figure">
<img src="./fig2-1.png" alt="Sample paths generated by random.move" /><p class="caption">Sample paths generated by random.move</p>
</div>
<h3 id="random-motion">Random Motion</h3>
<p>Perhaps the simplest kind of motion to model with the turtle is random motion (repeatedly going forward and turning random amounts). To implement this in a procedure, let’s assume that our computer language has a random-number generator rand (low, high) that outputs a random number between low and high. Using this we can write a procedure that takes four inputs specifying the ranges from which to select the inputs to forward and left:</p>
<pre><code>TO RANDOM.MOVE (D1, D2, A1, A2)
   REPEAT FOREVER
      LEFT RAND (A1, A2)
      FORWARD RAND (D1, D2)</code></pre>
<p>Even with this simple program, there is much to investigate. How do the bounds on the forwards or the turns affect the path? For instance, unless you make A1 negative the turtle will always turn left and the Y path will look roughly like a circle. In fact, except when A1 is chosen to be the negative of A2, the turtle’s turning will be biased in one direction or the other and this will be reflected in the shape of the path. Figure 2.1 shows some examples. How about the case where the turning is unbiased? Would you expect the turtle to go off &quot;to infinity&quot;? Or will it instead travel in a very large circle? More generally, can you say anything about the radius of the &quot;average path&quot; as a function of the bounds on the turns? One way to investigate these random motions is to write a record-keeping procedure that repeatedly runs, say, 100 rounds of the random.move loop and automatically records such statistics as the turtle’s heading and distance from the origin after those 100 rounds. Can you say anything about the average values of these quantities? (See exercises 2 and 3.)</p>
<p>Random-motion procedures such as this will often run the turtle off the edge of the display screen. Forcing the turtle to stay on the screen suggests modifying the random motion to model the behavior of an animal crawling in a box. To enable the turtle to do this, we’ll supply two new procedures: check.forward, which is just like forward except that it won’t allow the turtle to move if the result would take it outside of some fixed square box around the origin, and stuck, which tells whether or not the last move tried to place the turtle outside of the box. The checked.forward program works by moving the turtle &quot;invisibly&quot; to the new position, then using a subprocedure out.of.bounds? to check whether the new position is within bounds, and finally redoing the move visibly only if it is within bounds. This procedure makes use of some new operations in our turtle graphics system. hideturtle causes the turtle indicator not to be displayed; showturtle restores the indicator; xcor and ycor output, respectively, the <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span> coordinates of the turtle; turtle.state outputs (as a list) the position and heading of the turtle; and setturtle takes as input a list such as is produced by turtle.state and restores the turtle to that state:</p>
<pre><code>TO CHECK.FORWARD DISTANCE
   OLD.POSITION &lt;- TURTLE.STATE
   PENUP
   HIDETURTLE
   FORWARD DISTANCE
   FORWARD.FAILED &lt;- OUT.OF.BOUNDS?
   SETTURTLE OLD.POSITION
   PENDOWN
   SHOWTURTLE
   IF NOT FORWARD.FAILED THEN FORWARD DISTANCE

TO STUCK
   RETURN FORWARD.FAILED

TO OUT.OF.BOUNDS?
   IF EITHER
         ABS (XCOR) &gt; BOXSIZE
         ABS (YCOR) &gt; BOXSIZE
      THEN RETURN &quot;TRUE&quot;
      ELSE RETURN &quot;FALSE&quot;</code></pre>
<p>(abs is the absolute value function.)</p>
<div class="figure">
<img src="./fig2-2.png" alt="(a) Edge &quot;reflection&quot; generated by if stuck then right 180. (b) Edge-following behavior generated by if stuck then wriggle" /><p class="caption">(a) Edge &quot;reflection&quot; generated by if stuck then right 180. (b) Edge-following behavior generated by if stuck then wriggle</p>
</div>
<p>We can use these procedures to model appropriate behaviors that will keep the turtle in the box. Here, for example, is a version of random.move that has the turtle turn <span class="math">180<sup> ∘ </sup></span> whenever it runs into an edge:</p>
<pre><code>TO RANDOM.MOVE (D1, D2, A1, A2)
   REPEAT FOREVER
   LEFT RAND (A1. A2)
   CHECK.FORWARD RAND (D1, D2)
   IF STUCK THEN RIGHT 180</code></pre>
<p>shows a sample path. A second possibility for edge behavior is to have the turtle turn a little at a time, until it can go forward again. To do this, change the last line in the above procedure to if stuck then wriggle where wriggle is defined as</p>
<pre><code>TO WRIGGLE
   REPEAT
      RIGHT 1
      CHECK.FORWARD 1
   UNTIL NOT STUCK</code></pre>
<p>Figure 2.2b shows how this variation, incorporated into a random-motion procedure, causes the turtle to spend most of its time wandering along the edges of the box. You may have observed the similar behavior of a real insect trapped in a box. Of course, with a real insect, this behavior is often interpreted as the insect trying to get out of the box by following the walls. The turtle program calls into question the validity of such anthropomorphizing. If edge-following behavior can be produced by a simple combination of random motion plus wall avoidance, are we really justified in saying that the insect is &quot;trying&quot; to follow the edge? Could we legitimately make this claim about the turtle?</p>
<h3 id="directed-motion-modeling-smell">Directed Motion: Modeling Smell</h3>
<p>We can make our simulation more elaborate by allowing the turtle’s behavior to be affected by some stimulus. For example, we could imagine that there is some food located in the box with the turtle and design mechanisms that allow the turtle to find the food &quot;by sense of smell.&quot; There are many different ways we could provide turtles with information corresponding to an ability to smell. For example, the &quot;amount of smell&quot; could be a value that depends on how far the turtle is from the food (the larger the distance, the weaker the smell); or the turtle might not sense any particular level of smell, but at each move be able to detect whether the smell is getting stronger or weaker.</p>
<p>We’ll begin with the second possibility. This &quot;stronger-weaker&quot; kind of smell can be modeled by</p>
<pre><code>TO SMELL
   IF DISTANCE.TO.FOOD &gt; DISTANCE.LAST.TIME
      THEN RESULT &lt;- &quot;WEAKER&quot;
      ELSE RESULT &lt;- &quot;STRONGER&quot;
   DISTANCE.LAST.TIME &lt;- DISTANCE . TO . FOOD
   RETURN RESULT</code></pre>
<p>How can the turtle use this information to locate the food? One possibility is this: If the turtle finds that the smell is getting stronger, it keeps going in the same direction; otherwise it turns:</p>
<pre><code>TO FIND.BY.SMELL1
   REPEAT FOREVER
      FORWARD 1
      IF SMELL = &quot;WEAKER&quot; THEN RIGHT 1</code></pre>
<div class="figure">
<img src="./fig2-4.png" alt="find.by.smell3 illustrates degeneration of the algorithm under increasing randomness." /><p class="caption">find.by.smell3 illustrates degeneration of the algorithm under increasing randomness.</p>
</div>
<p>such intensity information to approach or avoid stimuli. Wood lice, for example, are observed to aggregate in moist places and avoid dry places. It is believed that they move in random directions, but that the moisture level governs their speed-they move more slowly when it is damp and hence spend most of their time in moist regions. This mechanism for aggregation is called orthokinesis. A different mechanism, klinokinesis, is claimed to govern the behavior of paramecia in aggregating in dark areas. In klinokinesis, the animal’s speed is constant, but the rate of turning varies with the intensity of the stimulus. (For more information on these and other orientation mechanisms, see G. Fraenkel and D. Gunn, Orientation in Animals [New York: Dover, 1961].) Try writing procedures embodying these mechanisms, and then try inventing new mechanisms. Good questions to guide your exploration are: How &quot;efficient&quot; is your method (how long does it take the turtle to reach the stimulus point)? How does the turtle’s path change as you vary the initial position and heading, or as you vary the parameters to the program? How does the mechanism degenerate as you incorporate some randomness into the turtle’s motion (for example, as in the find.by.smell3 procedure above)? Will even a slight amount of randomness destroy the turtle’s ability to reach the goal, or is your mechanism relatively stable with respect to random distortions?</p>
<p>In a more abstract vein, investigate the mathematical properties of simple polylike programs, but think of some aspect of the turtle’s motion as governed by the distance from some chosen point. Try, for example,</p>
<div class="figure">
<img src="./fig2-3.png" alt="Paths generated by find.by.smell2" /><p class="caption">Paths generated by find.by.smell2</p>
</div>
<p>Experimenting further, we can add a parameter to adjust the size of the turtle’s turns. This leads to an interesting study of how the geometry of the path varies with the turn angle. (See figure 2.3.)</p>
<pre><code>TO FIND.BY.SMELL.2 (TURN)
   REPEAT FOREVER
      FORWARD 1
      IF SMELL = &quot;WEAKER&quot; THEN RIGHT TURN</code></pre>
<p>A more realistic simulation would also include some of‘ the random motion of section 2.1.1:</p>
<pre><code>TO FIND.BY.SMELL3 (D1, D2, SMELL.TURN, RAND.TURN)
   REPEAT FOREVER
      FORWARD RAND (D1, D2)
      LEFT RAND ( - RAND.TURN, RAND.TURN )
      IF SMELL = &quot;WEAKER&quot; THEN RIGHT SMELL.TURN</code></pre>
<p>In this procedure the turtle’s motion is governed by two opposing tendencies: a &quot;random motion&quot; scaled by rand.turn and a &quot;directed motion&quot; scaled by smell.turn. This can be highlighted by adjusting the relative sizes of the two parameters. As an experiment, see how large rand.turn must be with respect to smell.turn before the random motion dominates completely and the turtle makes no discernible progress towards the food. (See figure 2.4.)</p>
<p>A different possibility for sensing &quot;smell&quot; is to have the turtle respond to an intensity directly, rather than to a change in intensity. Biologists have suggested various simple mechanisms by which animals can use</p>
<div class="figure">
<img src="./fig2-5.png" alt="Samples of paths generated by vary.step and vary.turn." /><p class="caption">Samples of paths generated by vary.step and vary.turn.</p>
</div>
<p>having the turtle turn a constant angle while going forward a distance that depends on the distance from the point:</p>
<pre><code>TO VARY.STEP (SIDE, ANGLE)
   REPEAT FOREVER
      FORWARD (FACTOR * SIDE)
      LEFT ANGLE</code></pre>
<p>Or take a constant forward step and vary the turn:</p>
<pre><code>TO VARY.TURN (SIDE, ANGLE)
   REPEAT FOREVER
      FORWARD SIDE
      LEFT (FACTOR * ANGLE)</code></pre>
<p>factor here can be something like</p>
<pre><code>TO FACTOR
   RETURN (1 / DISTANCE.TO.CHOSEN.POINT)</code></pre>
<p>Figure 2.5 shows some sample paths. As you can see, the procedures seem to do different sorts of things. vary.step tends to draw spirals, whereas vary.turn tends to draw bounded figures. Investigate these programs and come up with some conjectures about their behavior. Can you prove your oonqectures?</p>
<h3 id="modeling-sight">Modeling Sight</h3>
<p>As with smell, the first step in providing turtle with simulated sight is to A decide what information the &quot;eye&quot; should receive from the environment.</p>
<div class="figure">
<img src="./fig2-6.png" alt="keep.a.bearing: angle = 60" /><p class="caption">keep.a.bearing: angle = 60</p>
</div>
<p>We could hardly begin to model the complexity of human vision. A much simpler model ignores color, shape, and texture and registers merely the intensity of light reaching the eye. This kind of &quot;sight&quot; is not so different from the &quot;smell&quot; discussed above. Each sense receives some kind of intensity information from the environment. The major difference is that sight is directional; it depends on how the turtle is facing with respect to the stimulus. Algorithms for locating an object by sight are therefore different from &quot;smelling something out.&quot;</p>
<h4 id="facing-a-stimulus">Facing a Stimulus</h4>
<p>The first model for sight assumes that any creature able to see a light is able to turn to face that light. (See exercise 10.) Investigate what new things the turtle can do when given the ability to face a named point. For example, getting to the point is easy: Simply face the point and go forward. (But how does the turtle know when to stop?) Another use for the face command is to have the turtle move while keeping some point at a fixed bearing. The following procedure makes the turtle walk with a fixed bearing of angle with respect to a fixed point:</p>
<pre><code>TO KEEP.A.BEARING POINT ANGLE
   REPEAT FOREVER
      FACE POINT
      LEFT ANGLE
      FORWARD 1</code></pre>
<div class="figure">
<img src="./fig2-7.png" alt="Fields of vision for two-eye model" /><p class="caption">Fields of vision for two-eye model</p>
</div>
<p>If you try this procedure (figure 2.6) you will find that it causes the turtle to spiral about the point. Does this remind you of anything? How about a moth getting trapped by a light? Can you think of a reason why a moth would be trying to keep a light at a fixed bearing? Some people believe that moths and other night-flying insects have learned to fly along straight paths by keeping the moon at a constant bearing as they fly. Keeping a very distant light like the moon at a fixed bearing would indeed make the insects fly straight. When they confuse the moon with a nearby light, the fixed-bearing mechanism causes them to spiral.</p>
<h4 id="a-two-eye-model">A Two-Eye Model</h4>
<p>The next model focuses on how a creature might use vision in order to face a point. Assume that the turtle has two eyes, each with its own tield of vision, as shown in figure 2.7. We give the turtle the ability to tell whether a point is within each eye’s field of vision:</p>
<pre><code>TO RIGHT.EYE.SEES POINT
   IF BEARING (POINT) &gt; 300 THEN RETURN &quot;TRUE&quot;
   IF BEARING (POINT) &lt; 10 THEN RETURN &quot;TRUE&quot;
   RETURN &quot;FALSE&quot;

TO LEFT.EYE.SEES POINT
   IF BEARING (POINT) &gt; 350 THEN RETURN &quot;TRUE&quot;
   IF BEARING (POINT) &lt; 60 THEN RETURN &quot;TRUE&quot;
   RETURN &quot;FALSE&quot;</code></pre>
<p>(These procedures use a subprocedure called bearing that outputs the angle that the turtle would need to turn left in order to face a given point. Exercise 10 outlines how bearing can be implemented.)</p>
<div class="figure">
<img src="./fig2-8.png" alt="Behavior of head.for" /><p class="caption">Behavior of head.for</p>
</div>
<p>The turtle will know that it is facing roughly in the direction of a named point when the point lies in the field of vision on at least one side. So, as the turtle moves, it should keep checking that it can still see the point. Otherwise it turns until it can see the point:</p>
<pre><code>TO HEAD.FOR POINT
   REPEAT FOREVER
      IF EITHER
         LEFT.EYE.SEES (POINT)
         RIGHT.EYE.SEES (POINT)
      THEN FORWARD 10
      ELSE LEFT 10</code></pre>
<p>It may seem amazing that a turtle following this procedure manages to reach the specified point despite the fact that its way of heading for the point is so inaccurate. (See figure 2.8.) This illustrates the effectiveness of a feedback mechanism — constant adjustment can often compensate for lack of accuracy. You might try combining this mechanism with some of the random-motion procedures of subsection 2.1.1.</p>
<h4 id="a-two-eye-model-with-intensity">A Two-Eye Model With Intensity</h4>
<p>A more elaborate model for vision registers not only the presence of a light source in the visual field, but also the intensity that each eye receives from the source. This intensity depends on the strength of the source, the distance of the source from the eye, and the angle at which the light strikes the eye. The intensity is greatest when the light hits the eye straight on and tapers off to zero as the light source moves toward the edge of the visual field.</p>
<div class="figure">
<img src="./fig2-9.png" alt="Path generated by find.by.sight" /><p class="caption">Path generated by find.by.sight</p>
</div>
<p>Suppose we have procedures intensity.left and intensity.right that output the intensity each eye receives from a light source. (We’ll worry about how to design these intensity procedures later.) There is a simple yet effective way to incorporate such intensity information in a feedback mechanism to make the turtle approach the light source:</p>
<pre><code>TO FIND.BY.SIGHT SOURCE
   REPEAT FOREVER
      FORWARD 1
      IF INTENSITY.LEFT (SOURCE) &gt; INTENSITY.RIGHT (SOURCE)
      THEN LEFT 10
      ELSE RIGHT 10</code></pre>
<p>The turtle walks forward while trying to keep the amount of light received at both eyes in balance. If the turtle sees more light to its right, it turns slightly to the right. If it sees more light to its left, it turns slightly to the left. (See figure 2.9.)</p>
<p>Some animals may actually use this mechanism for approaching light sources. Biologists have obtained experimental evidence for this conclusion by taking an animal and masking one of its eyes. What happens when the animal tries to approach the light? You can simulate this experiment by modifying intensity.left to always return 0 and have the turtle follow the find.by.sight procedure. Now the turtle will always turn right, and will therefore travel in a circle. Biologists call this behavior &quot;circus movement.&quot; It has been observed in experiments with numerous species of insects. A variation of this experiment is to modify intensity.left to output half its normal value. (This corresponds to an animal with weak vision in one eye.) What kind of path does find.by.sight produce now? Does the animal still reach the light? How does the path degenerate to a circus movement as the eye becomes weaker and weaker?</p>
<p>Finally, consider what happens when there are two or more light sources. The intensity for each eye can be found by adding together the intensities from the individual sources:</p>
<pre><code>TO FIND.BY.SIGHT2 (SOURCE1, SOURCE2)
   REPEAT FOREVER
      FORWARD 1
      TOTAL.LEFT &lt;- INTENSITY.LEFT (SOURCE1)
                       + INTENSITY.LEFT (SOURCE2) 
      TOTAL.RIGHT &lt;- INTENSITY.RIGHT (SOURCE1)
                       + INTENSITY.RIGHT (SOURCE2)
      IF TOTAL.LEFT &gt; TOTAL.RIGHT
      THEN LEFT 10
      ELSE RIGHT 10</code></pre>
<p>How does the turtle behave? Does it go to the stronger light? Between the lights? Keep records of what happens for sources with different strengths and for different initial positions of turtle and sources. This &quot;two-light experiment&quot; is often performed with real insects. The intensity procedures used in these projects can be designed according to a model given in the book by Fraenkel and Gunn mentioned above. They compute the intensity of light falling on the eye as <span class="math">(<em>S</em> / <em>D</em><sup>2</sup>)cos<em>A</em></span> where <span class="math"><em>S</em></span> is the strength of the source, <span class="math"><em>D</em></span> is the distance from the source, and <span class="math"><em>A</em></span> is the angle at which light from the source strikes the eye. (See figure 2.10.) The turtle procedure based on this would be</p>
<pre><code>TO INTENSITY.LEFT SOURCE
   IF NOT LEFT.EYE.SEES (SOURCE) THEN RETURN O
   FACTOR + STRENGTH / (DIST(SOURCE) | 2)
   ANGLE + BEARING (SOURCE) - 45
   RETURN (FACTOR * COS(ANGLE) </code></pre>
<p>strength here is a parameter you supply to indicate the intensity of the source. Note the computation of angle, which reflects the fact that the left eye is offset <span class="math">45<sup> ∘ </sup></span> from the turtle’s heading. intensity.right is implemented in a similar fashion.</p>
<h4 id="exercises-for-section">Exercises for Section</h4>
<div class="figure">
<img src="./fig2-10.png" alt="Intensity of light seen by eye is (S / D^2) \cos A." /><p class="caption">Intensity of light seen by eye is <span class="math">(<em>S</em> / <em>D</em><sup>2</sup>)cos<em>A</em></span>.</p>
</div>
<ol style="list-style-type: decimal">
<li><p><span class="math">[<em>P</em>]</span> In the random.move procedure of 2.1.1, how does the turtle’s path change if the turning is generated by left rand(0, 50) followed by right rand(0, 50) rather than left rand(-50,50)? How is the distribution of numbers produced by rand(-50, 50) different from that of rand(0, 50) - rand(0, 50)? [A]</p></li>
<li><p><span class="math">[<em>P</em><em>D</em>]</span> Starting with the turtle facing straight up, run the random.move procedure until the turtle exceeds distance n from the start, that is, crosses a circle of radius <span class="math"><em>n</em></span> centered at the starting point. At what point did the turtle intersect the circle? Repeat this process over and over and study the distribution of intersection points on the circle. What is its &quot;average value&quot;? How does the distribution change as <span class="math"><em>n</em></span> varies? Answer the same sort of questions about the number of steps taken before crossing the circle.</p></li>
<li><p><span class="math">[<em>P</em><em>D</em><em>D</em>]</span> If the turtle follows randommove with the turn angle evenly distributed between -10 and 10, will you expect it to go off to infinity, or to travel in a large circle? Make some studies of this phenomenon. For example, graph the turtle’s distance from the origin after n steps. ls there an average graph for many tries of this experiment? Alternatively, if the angle is not evenly distributed, the program will cause the turtle to tend to walk in circles. But do the circles wander off to infinity? How fast?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Investigate randomized poly procedures such as</p>
<pre><code>TO RANDOM.POLY (SIDE, ANGLE)
   REPEAT FOREVER
      FORWARD SIDE
      LEFT (ANGLE * RAND (LOW, HIGH))</code></pre></li>
<li><p><span class="math">[<em>P</em>]</span> In the find.by.smell2 procedure of 2.1.2, how does the time required to reach the food vary with the angle the turtle turns? In the randomized find.by.smell3 procedure, what is the average time as a function of the smell.turn and rand.turn? (Do some experiments and take statistics.)</p></li>
<li><p><span class="math">[<em>P</em>]</span> Implement procedures for orthokinesis and klinokinesis. Which is more efficient? Which is more stable under adding a bit of randomness? Does the stability depend on the kind of randomness?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Play around with the vary.step procedure of 2.1.2. Does the turtle always spiral inwards or outwards? Does this depend on the initial position or heading with respect to the fixed point? Try also taking different values for factor, such as making it directly proportional to the distance from the point or inversely proportional to the distance squared.</p></li>
<li><p><span class="math">[<em>P</em>]</span> What can you say about the vary.turn procedure? Does the turtle always stay within a bounded distance from the fixed point? Try this also with the variations on factor, as in exercise 7.</p></li>
<li><p><span class="math">[<em>P</em>]</span> Try procedures like vary.step and vary.turn, only this time where factor depends on the change in distance (as with the smell procedure of 2.1.1). For instance, suppose factor is equal to distance <span class="math"> − </span> distance.last.time. Consider the procedure</p>
<pre><code>REPEAT FOREVER
   FORWARD SIDE
   LEFT FACTOR</code></pre>
<p>Prove that this can never draw a simple closed figure. [HA]</p></li>
<li><p><span class="math">[<em>P</em>]</span> Implement the face and bearing procedures used in the sight programs of 2.1.3. bearing should return the amount the turtle needs to turn left in order to face the point. Then face can be immediately implemented as left (bearing (point)). bearing, in turn, can be implemented in terms of the turtle’s heading and another function, towards, which outputs the heading of the line directed from the turtle to the point. This can be computed using an arctangent function. [A]</p></li>
<li><p><span class="math">[<em>P</em>]</span> Make a careful investigation of the two- (or more) light experiment. How does the turtle’s path vary with the relative intensities of the light?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Suppose the turtle lives in a square room with a light at each corner. Instead of using a rectangular coordinate system, the turtle can &quot;get its bearings&quot; by measuring the observed angles between the lights. Suppose the turtle starts at some point <span class="math"><em>p</em></span> and records the observed angles. Now move the turtle to a different point. Design a simple feedback algorithm that enables the turtle to return to <span class="math"><em>p</em></span> by moving and watching how the angles change.</p></li>
</ol>
<h2 id="turtles-interacting">Turtles Interacting</h2>
<p>One natural extension of the previous section’s &quot;turtle biology&quot; is to consider multiple turtles and the interactions produced by simple algorithms. As we shall see, even simple algorithms may lead to complex phenomena, and a study of these phenomena can be an invitation to the theory of &quot;differential games.&quot;</p>
<h3 id="predator-and-prey">Predator and Prey</h3>
<p>Consider how the find.by.smell mechanism of subsection 2.1.2 would behave if the food were also moving, as in the case of a predator trying to catch dinner. There are many possible variations to try. Suppose, for example, that the hunted creature, unaware of the predator’s intentions, moves round and round in a circle and that the predator follows the prey according to the find.by.smell2 procedure of 2.1.2. One way to implement this interaction is to write separate procedures for predator and prey that describe how each creature generates a single forward step:</p>
<pre><code>TO PREY.STEP (SPEED, TURN)
   FORWARD SPEED
   RIGHT TURN

TO PREDATOR.STEP (SPEED, TURN)
   FORWARD SPEED
   IF SMELL = &quot;WEAKER&quot; THEN RIGHT TURN</code></pre>
<p>Now supply a monitor procedure called execute.together that executes these two procedures alternately, over and over;</p>
<pre><code>TO EXECUTE.TOGETHER (PREDATOR.PROCESS, PREY.PROCESS)
   REPEAT FOREVER
   ; set the turtle at the predator state and
   ; execute the predator&#39;s procedure
      EXECUTE.STEP (PREDATOR.PROCESS, PREDATOR.STATE)
      ; save the predator state for next time
      PREDATOR.STATE &lt;- TURTLE.STATE
      ; execute the prey&#39;s procedure
      EXECUTE.STEP (PREY.PROCESS, PREY.STATE)
      ;save the prey state
      PREY.STATE &lt;- TURTLE.STATE</code></pre>
<p>The inputs to this procedure are to be the steps above, with their inputs. For instance,</p>
<p>execute.together(&quot;prey.step(1,1)&quot; . &quot;predator.step(2,90)&quot;) makes the prey and predator execute simultaneously.</p>
<p>The execute.step procedure is responsible for executing the process in the right place. It makes the turtle follow a given process starting from a given state.</p>
<pre><code>TO EXECUTE.STEP (PROCESS, STATE)
   ; with the pen up move the turtle to the starting state
   PENUP
   SETTURTLE STATE
   ; put the pen down and execute the process
   PENDOWN
   EXECUTE PROCESS</code></pre>
<p>At any point during the process, the variables predator.state and prey.state specify the position and heading of the creatures. Set these to their initial values before starting the execute.together procedure. (Note: Some computer languages have built-in facilities for parallel processing, which eliminate the need for such a execute.together procedure. But since these languages are not yet widespread, we show how to implement this in a more conventional language. Also, see appendix A for details about the execute command.)</p>
<div class="figure">
<img src="./fig2-11.png" alt="Closed-path phenomenon. Predator uses find.by.smell with turn = 90; prey moves in circle. Predator speed is twice prey speed" /><p class="caption">Closed-path phenomenon. Predator uses find.by.smell with turn = 90; prey moves in circle. Predator speed is twice prey speed</p>
</div>
<p>Figure 2.11 shows the result of the two procedures with the predator’s turn equal to <span class="math">90<sup> ∘ </sup></span> and with predator moving twice as fast as prey. As you can see, the find.by.smell mechanism, which works so well with a fixed food source, does very poorly when the food is moving. The geometry of the path, however, is interesting. Notice that, after an initial segment, the predator’s path is closed. Can you see why? Investigate this phenomenon for different turn angles in the predator.step procedure and also for varying relative speeds of predator and prey. Now conduct a similar investigation with some of the other animal-orientation mechanisms of section 2.1. Do they all do so poorly when the food is moving? Or consider the use of these simple algorithms as avoidance mechanisms. For example, set up a situation in which A a predator uses one of the sight algorithms of 2.1.3 to chase another creature that is using an avoid.by.smell procedure. (Note: To convert find.by.smell to avoid.by.smell, simply modify the procedure so that the creature will turn whenever the smell is getting stronger.) Any such combination of the behaviors illustrated in section 2.1 can serve as the basis for a project.</p>
<h3 id="following-and-chasing">Following and Chasing</h3>
<p>In a slightly different framework, we can consider &quot;chase and evade&quot; strategies for two turtles. The simplest strategy is for the chasing turtle to run directly towards the evader, and for the evader to run directly away from the chaser. More interesting is the situation when both creatures are constrained to stay within a square box. There are lots of possibilities for projects here. Begin by programing simple strategies using the execute.together framework of 2.2.1. Now make the chaser a bit smarter so that he can generally catch the evader — for example, by driving him into a corner. Now make the evader smarter, so that he can avoid the trap. Now make the chaser smarter still, and so on. When you get some really clever programs, modify the setup so that you control one of the creatures by hand and the computer controls the other. Are your clever procedures more skilled at the chase-evade game than you are? As a test of skill and strategy, try varying the relative speeds of chaser and evader. If they both move at the same speed, can the evader always avoid being caught?</p>
<div class="figure">
<img src="./fig2-12.png" alt="Spiral paths generated by four &quot;bugs&quot; starting at vertices of square." /><p class="caption">Spiral paths generated by four &quot;bugs&quot; starting at vertices of square.</p>
</div>
<p>It’s also interesting to examine the paths generated by interacting creatures. One example is the widely known mathematical problem of the four &quot;bugs&quot; who start at the vertices of a square and move at the same speed, each one following the bug to its right. Set this up using the execute.together procedure (suitably modified to handle four creatures) and the follow mechanism:</p>
<pre><code>TO FOLLOW.THAT.BUG
   FACE THAT.BUG
   FORWARD 1</code></pre>
<p>Now make bug 1 follow bug 2, bug 2 follow bug 3, bug 3 follow bug 4, and bug 4 follow bug 1:</p>
<pre><code>EXECUTE.TOGETHER &quot;FOLLOW BUG2&quot; &quot;FOLLOW BUG3&quot; 
            &quot;FOLLOW BUG4&quot; &quot;FOLLOW BUG1&quot;</code></pre>
<p>Figure 2.12 shows the paths generated by the four bugs. As you can see, they all meet at a single point. One notable property of the &quot;four bugs&quot; situation is that the length of the path traveled by each bug is equal to the side of the original square. See if you can prove that. Modify follow to keep track of how far each bug moves, and compare the computed value with the theoretical value. Here is another interesting chase phenomenon with two creatures, the chaser and the evader. The chaser heads directly towards the evader:</p>
<div class="figure">
<img src="./fig2-13.png" alt="Stable configuration generated by interaction of chase and evade" /><p class="caption">Stable configuration generated by interaction of chase and evade</p>
</div>
<p>But the evader, instead of running directly away, heads at a constant <span class="math">90<sup> ∘ </sup></span> bearing from the chaser:</p>
<pre><code>TO CHASE
   FACE EVADER
   FORWARD CHASE.SPEED

TO EVADE
   FACE CHASER
   RIGHT 90
   FORWARD EVADE.SPEED</code></pre>
<p>When the two creatures move at the same speed, the chaser always catches up, as you might expect. But when the evader’s speed is increased, both chaser and evader begin to spiral in towards each other. The spirals eventually degenerate into closed circles (see figure 2.13), which are stable configurations for the chaser-evader situation. Even though the algorithm seems &quot;directed,&quot; the creatures end up retracing their paths over and over.</p>
<p>A multiple-turtle setup can also be used to investigate some of the phenomena in the area of &quot;differential games,&quot; which has to do with finding optimal strategies in situations similar to &quot;chase and evade.&quot; An example is provided by a &quot;target defending&quot; game consisting of two players and a target. The attacker’s object is to get as close to the target as possible; the defender’s object is to intercept the first player as far from the target as possible. Assume that both players have the same speed and that the defender starts out closer to the target. It turns out that this situation has a simple optimal strategy, which is the same for both players: Each time you move, head for the point that is closest to the target and that lies on the perpendicular bisector of the line joining your position to your opponent’s (see exercise 11). Of course, if both players are computerized and move with optimal strategy (figure 2.14a) the resulting paths aren’t very interesting-a better idea might be to arrange things so that you control one player and the computer controls</p>
<div class="figure">
<img src="./fig2-14.png" alt="Targetrdefending game. (a) Both players following optimal strategy. (b) Attacker manually controlled; defender computer-controlled following optimal strategy. the other (see figure 2.14b). Try playing against the computer both on attack and on defense. How well can you do in comparison with the theoretical optimum?" /><p class="caption">Targetrdefending game. (a) Both players following optimal strategy. (b) Attacker manually controlled; defender computer-controlled following optimal strategy. the other (see figure 2.14b). Try playing against the computer both on attack and on defense. How well can you do in comparison with the theoretical optimum?</p>
</div>
<p>Books on differential games suggest many more situations that can be made into games between a person and a computer. In general these are very difficult to analyze for optimal strategies; the target-defending game explained above is unusually straightforward. There is a Way to simplify the situation: Restrict all creatures to move on a square grid; that is, only allow turns that are multiples of 900 and distances that are multiples of some fixed length, or, alternatively, specify that at each step a creature can move only to an adjacent square in the grid.</p>
<h4 id="exercises-for-section-1">Exercises for Section</h4>
<ol style="list-style-type: decimal">
<li><p><span class="math">[<em>P</em><em>D</em>]</span> Can you verify, as asserted in subsection 2.2.1, that a predator using find.by.smell to chase a creature moving in a circle will eventually travel in a closed path? How does this depend on the angle turned? On the relative speeds of predator and prey? On the initial positions?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Set up a predator using find.by.sight (subsection 2.1.3) to chase a prey using avoid.by.smell. Does he catch him if the two creatures have equal speeds? Does this depend on the angles that the creatures turn? What happens as the speeds vary?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Implement a general execute.together facility that can handle, say, two, three, or four creatures simultaneously. Notice that the procedure given in the text draws only the creatures’ paths and not the creatures themselves. Maybe you’d like to improve upon this.</p></li>
<li><p><span class="math">[<em>P</em>]</span> Implement a general &quot;chase-evade&quot; system that allows you to specify procedures to guide both chaser and evader, or to control either creature by hand.</p></li>
<li><p><span class="math">[<em>P</em><em>D</em>]</span> Set up the &quot;four bugs&quot; simulation. Have the system calculate the distance traveled by each bug. Does your result agree with the claim in the text that this distance is equal to the side of the original square? Can you prove this claim?</p></li>
<li><p><span class="math">[<em>P</em><em>D</em><em>D</em>]</span> Suppose that, instead of four bugs, we have three bugs starting in the vertices of an equilateral triangle. How far does each bug travel now? Generalize this to consider <span class="math"><em>n</em></span> bugs starting at the vertices of a regular n-gon. Given a formula for the distance traveled by each bug in terms of the side of the <span class="math"><em>n</em></span>-gon, and check your formula by doing some computer simulations. [A]</p></li>
<li><p><span class="math">[<em>P</em>]</span> Make up and investigate some variations on the &quot;four bugs&quot; problem. For example: Suppose the bugs start on a figure that is not so symmetric. (How about a rectangle?) Suppose one bug goes faster than the other. Suppose instead of each bug following the one to its left, they follow each other in some other order.</p></li>
<li><p><span class="math">[<em>P</em>]</span>What kinds of initial conditions, speeds, and following mechanisms will ensure that all bugs eventually meet at one point?</p></li>
<li><p><span class="math">[<em>P</em><em>D</em>]</span> Investigate the modified chase-evade simulation that yields the stable circles of 2.2.2, assuming that the evader movers faster than the chaser. Why does the process stabilize? When it does stabilize, what is the approximate distance of chaser from evader? How does this distance depend on the speeds of chaser and evader? Give a formula for the distance.</p></li>
<li><p><span class="math">[<em>P</em>]</span> Find other chase-evade pairs that produce stable configurations.</p></li>
<li><p>In the &quot;target-defending&quot; game, give a formula for the coordinates of the point to head for when following the optimal strategy, and use this to implement the strategy on the computer.</p></li>
<li><p><span class="math">[<em>D</em>]</span> Analyze the target-defending game in the case where the two players have different speeds. What is the optimal strategy for each player?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Carry out a detailed study of chase-evade for creatures moving on a grid. Invent strategies and counterstrategies. Can the evader always avoid getting caught if the two creatures move at equal speeds? If they move at different speeds?</p></li>
</ol>
<div class="figure">
<img src="./fig2-15.png" alt="Equiangular spiral formed by eqspi with angle = 20, scale = 1.1." /><p class="caption">Equiangular spiral formed by eqspi with angle = 20, scale = 1.1.</p>
</div>
<h2 id="growth">Growth</h2>
<p>Besides simulating animal behavior, another good source of turtle biology projects is modeling patterns of growth. In this section we’ll examine two models: the equiangular spiral, which emerges in the shapes of shells and horns; and models for branching in the growth of trees.</p>
<h3 id="equiangular-spirals">Equiangular Spirals</h3>
<p>We’ve already seen in section 1.1 how to transform the poly program</p>
<pre><code>TO POLY SIDE ANGLE
   FORWARD SIDE
   LEFT ANGLE
   POLY SIDE ANGLE</code></pre>
<p>into a program for drawing spirals:</p>
<pre><code>TO POLYSPI (SIDE, ANGLE, INCREMENT)
   FORWARD SIDE
   LEFT ANGLE
   POLYSPI (SIDE + INCREMENT, ANGL, INCREMENT)</code></pre>
<p>Here is another way to make a spiral: Rather than increasing the side by adding a fixed increment, multiply the side by a constant scale factor:</p>
<pre><code>TO EQSPI (SIDE, ANGLE, SCALE)
   FORWARD SIDE
   LEFT ANGLE
   EQSPI (SIDE * SCALE, ANGLE, SCALE)</code></pre>
<p>This spiral (shown in figure 2.15) is called aniequiangular spiral (also sometimes called a logarithmic spiral). Connecting the vertices of the spiral to a central point shows that the spiral can be generated by successions of similar triangles, each one built upon the previous. This principle of constructing a pattern through the accumulation of similar shapes lies behind the spiral’s appearance in many biological forms, especially in shells and horns. The nautilus shell, shown in figure 2.16, gives a clear illustration. The entire shell is constructed as a sequence of &quot;chambers,&quot; each chamber built on the previous chamber and similar to it. (The chambers are similar because the creature doesn’t change shape as it moves from chamber to chamber; it just grows.) The result is that corresponding points of successive chambers lie on equiangular spirals. We’ll exhibit a turtle program that mimics this kind of equiangular growth, using quadrilateral chambers. Each quadrilateral, as indicated in figure 2.17a, will be specified to the program by three sides and two angles. If the turtle starts in the lower left corner, the base and sides of the quadrilateral can be drawn by</p>
<pre><code>TO CHAMBER (BASE, S1, S2, A1, A2)
; save the position of the lower left vertex
   LOWER.LEFT + TURTLE.STATE
   ; draw the base and right side and save the
   ; position of the upper right vertex (see below)
   FORWARD BASE
   LEFT A2
   FORWARD S2
   UPPER.RIGHT + TURTLE.STATE
   ; return to the lower left vertex and draw the left side
   PENUP
   SETTURTLE LOWER.LEFT
   PENDOWN
   LEFT A1
   FORWARD S1</code></pre>
<div class="figure">
<img src="./fig2-16.png" alt="The shell of the chambered nautilus clearly exhibits the spiral-growth phenomenon." /><p class="caption">The shell of the chambered nautilus clearly exhibits the spiral-growth phenomenon.</p>
</div>
<div class="figure">
<img src="./fig2-17.png" alt="The spiral.grow procedure." /><p class="caption">The spiral.grow procedure.</p>
</div>
<p>At the end of this procedure the turtle is sitting at the upper left corner 1 of the chamber, which is the same as the lower left vertex of the next chamber. To prepare for drawing the next chamber we must point the turtle along the base of the next chamber, that is, point the turtle towards the upper right vertex of the chamber just drawn. We can do this using the face procedure of section 2.1, whose implementation is outlined in exercise 10 of that section. Having done this, we are ready to draw the next chamber. The angles of the next chamber are the same as before. The base of the next chamber is the top edge of the previous chamber, and the size of the next chamber is determined by the ratio of the old base to the new base. All together, the program for spiral growth is</p>
<pre><code>TO SPIRALGROWTH (BASE, S1, S2, A1, A2)
; draw one chamber and face along the edge of the new chamber
   CHAMBER (BASE, S1, S2, A1, A2)
   FACE UPPER.RIGHT
   ; the length of the next chamber&#39;s base is the distance
   ; from the current location to the upper right corner of
   ; the chamber just drawn
   NEXT.BASE &lt;- DISTANCE (UPPER.RIGHT)
   ; compute the ratio of the sides of the new chamber to the
   ; sides of the previous chamber
   R &lt;- NEXT.BASE/BASE
   ; now repeat the process, using as inputs
   ; the sides and angles of the new chamber
   SPIRAL.GROWTH (NEXT.BASE, S1 * R, S2 * R, A1, A2)</code></pre>
<div class="figure">
<img src="./fig2-18.png" alt="Demonstration that curves of equiangular spiral are everywhere the same. Chunk B is the same as chunk A blown up by a factor of 3" /><p class="caption">Demonstration that curves of equiangular spiral are everywhere the same. Chunk B is the same as chunk A blown up by a factor of 3</p>
</div>
<p>The recursive structure of the program implies that each chamber generates a new chamber. There is no stop rule and the program goes on forever. Whether the chambers increase or decrease in size depends on the initial sides and angles. A sample &quot;shell&quot; drawn by this program is illustrated in figure 2.17.</p>
<h4 id="growing-turtle-geometry">Growing Turtle Geometry</h4>
<p>Equiangular spirals underlie uniform growth such as the spiral.growth shown above in the same way that a circle underlies any turtle program that does the same thing over and over. The reason for both of these facts becomes clearer when one describes the equiangular spiral and the circle as curves that are &quot;everywhere the same.&quot; In the case of a circle, that means any chunk of the circle can match any other chunk of the circle if you are allowed to move and turn the iirst chunk. In the case of the spiral, one must allow changing scale (making a bigger or smaller model of a piece), in addition to moving and turning, to show that one piece matches another. See figure 2.18.</p>
<p>One can augment turtle geometry to make scale changes by introducing a new &quot;scaled forward&quot; command and a grow command to change scale:</p>
<pre><code>TO S.FORWARD DISTANCE
   FORWARD (SCALE * DISTANCE)
 
TO GROW FACTOR
   SCALE &lt;- (SCALE * FACTOR)</code></pre>
<p>scale should now be considered a part of the turtle state — it’s a kind of &quot;size&quot; of the turtle that determines the size of the next step just as heading determines the direction of the next step. (scale should start equal to 1.) The analog to poly is precisely eqspi:</p>
<pre><code>TO EQSPI (SIZE, ANGLE, FACTOR)
   REPEAT FOREVER
      S.FORWARD SIZE
      RIGHT ANGLE
      GROW FACTOR</code></pre>
<p>You should be able to show that any looping program which involves only s.forward, right, and grow will have an eqspi skeleton, just as poly is the skeleton for looping programs without grow (see exercise 10). Incidentally, a circle is an &quot;equiangular spiral with no growth&quot; in the same way a line is &quot;a circle with no turning.&quot; Finally, notice that the chambered growth shown in figure 2.17 ensures that the growth is uniform by having the bottom edge of one chamber be related to the bottom edge of the preceding precisely as the ratio of top to bottom edge of the previous chamber. Because the chambers are constructed to be similar, that ratio never changes.</p>
<h3 id="branching-processes-a-lesson-in-recursion">Branching Processes: A Lesson in Recursion</h3>
<p>A different kind of growth pattern we can mimic with turtle graphics is the branching process that characterizes the growth of trees. We’ll start by drawing a very regular binary tree, that is, a tree in which each branch sprouts two more branches. We’ll make the length of each sprouted branch half that of the parent. Conceptually, each branch consists of a straight line, with two more branches at its end. Notice the fundamentally recursive nature of this description — a branch consists of something (the stem) plus sub-branches (things with the same structure as the branch). In a program, that structure will appear in the standard recursive way, as a procedure calling itself as a subprocedure.</p>
<p>If we assume that the branching angle is <span class="math">45<sup> ∘ </sup></span>, then a first try at a program might be</p>
<pre><code>TO BRANCH LENGTH
; draw the main branch
   FORWARD LENGTH
   ; turn to point along the left
   ; secondary branch and draw it
   LEFT 45
   BRANCH LENGTH / 2
   ; now draw the right secondary branch
   RIGHT 90
   BRANCH LENGTH / 2</code></pre>
<p>But if we try this procedure, we’ll find that it has a bug: The turtle starts drawing a branch, then its left secondary branch, then that branch’s left secondary branch, and so on and so on. No right branches ever get drawn. At some point, we must make the process stop generating new left branches and come back to do the right branches. We’ll accomplish this by giving the branch process a second input called level, which counts down as the program moves from each branch to its secondary. We can think of level as labeling the type (complexity) of the branch: A level 1 branch is a tip (a branch with no secondaries); a level 2 branch will sprout two level 1 secondaries; a level 3 branch will sprout level 2 secondaries, and so on. The program should stop generating secondary branches whenever the level reaches 0:</p>
<pre><code>TO BRANCH (LENGTH, LEVEL)
   IF LEVEL = 0 THEN RETURN
   FORWARD LENGTH
   LEFT 45
   BRANCH (LENGTH/2, LEVEL - 1)
   RIGHT 90
   BRANCH (LENGTH/2. LEVEL · 1)</code></pre>
<div class="figure">
<img src="./fig2-19.png" alt="The branch procedure. (a) Version with state bug, level = 3. (b) Debugged version, level = 3. (c) Debugged version, level = 6." /><p class="caption">The branch procedure. (a) Version with state bug, level = 3. (b) Debugged version, level = 3. (c) Debugged version, level = 6.</p>
</div>
<p>Unfortunately, as shown in figure 2.19a, there is still a bug in the program. This bug, which is tricky to find, comes up often in such recursive descriptions: We must ensure that after drawing the left secondary branch the turtle returns to the base of that branch, or else the right 90 instruction will not align the turtle correctly for drawing the right secondary branch. Ir1 other words, we must ensure that the process that draws the left secondary branch restores the state of the turtle to what the state was before the process began. The technical term for a process that leaves the turtle in the same state in which it found it is state transparent.</p>
<p>branch will work only if its sub-branches are state-transparent. But since the sub-branches as programs are just copies of branch itself, branch must be made state-transparent. (In a recursive society all you must do to make sure your offspring have some property is have it yourself.) Here is the debugged program:</p>
<pre><code>TO BRANCH (LENGTH, LEVEL)
   IF LEVEL = 0 THEN RETURN
   FORWARD LENGTH
   LEFT 45
   BRANCH (LENGTH/ 2, LEVEL - 1)
   RIGHT 90
   BRANCH (LENGTH/2, LEVEL - 1)
   ; turn and back up to make the
   ; procedure state-transparent
   LEFT 45
   BACK LENGTH</code></pre>
<p>Using this simple binary tree as a model, we can go on to construct figures that look more like real trees. For example, we might add inputs to the program to allow some other variation of the size of the secondary branches besides &quot;divide by 2.&quot; Another possibility is to make the length of stem depend not on the level, but on whether the stem belongs to a left or a right sub-branch.</p>
<div class="figure">
<img src="./fig2-20.png" alt="lbranch and rbranch have node in common" /><p class="caption">lbranch and rbranch have node in common</p>
</div>
<p>The cleanest way to implement this idea is to have separate left and right procedures that produce stems of different lengths. As the dashed lines in figure 2.20 indicate, each of these must prepare for the next-level branch. Though the preparation is not hard, it is more than half the procedure, and both left and right branch procedures must do it. So it makes sense to make it a subprocedure called node. We can also make node responsible for the stop rule, which is common to the two procedures.</p>
<div class="figure">
<img src="./fig2-21.png" alt="Branching figures drawn by lbranch" /><p class="caption">Branching figures drawn by lbranch</p>
</div>
<pre><code>TO LBRANCH (LENGTH, ANGLE, LEVEL)
; draw a long stem
   FORWARD (2 * LENGTH)
   ; do next level
   NODE (LENGTH, ANGLE, LEVEL)
   ; make LBRANCH state-transparent
   BACK (2 * LENGTH)
   TO RBRANCH (LENGTH, ANGLE, LEVEL)
   ; draw a short stem
   FORWARD LENGTH
   ; do next level
   NODE (LENGTH, ANGLE, LEVEL)
   ; make RBRANCH state-transparent
   BACK LENGTH

TO NODE (LENGTH, ANGLE, LEVEL)
   IF LEVEL = 0 THEN RETURN
   ; point along left branch and draw it
   LEFT ANGLE
   LBRANCH (LENGTH, ANGLE, LEVEL - 1)
   ; draw right branch
   RIGHT (2 * ANGLE)
   RBRANCH (LENGTH, ANGLE, LEVEL - 1)
   ; make NODE state-transparent
   LEFT ANGLE</code></pre>
<p>You can start the process with either lbranch or rbranch. Figure 2.21 shows some of these trees. Notice that at first sight the growth pattern looks random, even though it is actually very regular. More information on the spiral shapes of shells, horns, claws, and teeth can be found in On Growth and Form by D’Arcy Thompson (abridged edition; Cambridge University Press, 1961). The branch procedure is adapted from a model discussed in Patterns in Nature, by Peter S. Stevens (Boston: Atlantic Monthly Press, 1974). Both of these books are well worth having a look at if you are interested in mathematical models in biology.</p>
<h4 id="exercises-for-section-2">Exercises for Section</h4>
<div class="figure">
<img src="./fig2-22.png" alt="Examples of animal horns that can be modeled by spiral.growth" /><p class="caption">Examples of animal horns that can be modeled by spiral.growth</p>
</div>
<ol style="list-style-type: decimal">
<li><p><span class="math">[<em>P</em>]</span> Figure 2.22 shows some animal horns. Can you find inputs to the spiral.growth program that produce horns shaped like these?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Invent variants of the spiral.growth procedure in which the chambers are not quadrilaterals.</p></li>
<li><p><span class="math">[<em>P</em>]</span> Efficiency experts may object that our spiral.growth procedure is inefficient in that the ratio of one chamber to the next should be computed only once, rather than each time a new chamber is drawn. But our version is easy to modify so that this ratio (and hence the shape of the chambers) can be varied from one chamber to the next. We might let the left and right sides grow more slowly (with a different ratio) than the tops and bottoms, and so get a figure which becomes stubbier as it grows. Experiment with possibilities like these. What kinds of shapes arise if the change in growth is periodic (seasonal)? If the rate of growth is random?</p></li>
<li><p>What is the total length of all the lines drawn by the branch procedure for a given length and level?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Modify node so that the choice of whether the left or the right sub-branch is to be the long one is made randomly at each level.</p></li>
<li><p>Make a branching model in which each left sub-branch is twice as long as each right sub-branch and sprouts two left-right branches. What is the total length of all the branches drawn for a given length and level? [HA]</p></li>
<li><p><span class="math">[<em>P</em>]</span> Create some variations that introduce randomness into the model given in the previous exercise. For instance, the left branch may sprout either one or two branches at each level.</p></li>
<li><p><span class="math">[<em>D</em>]</span> Does eqspi (2, 2, 2), eqspi (1,1,1), eqspi (.5, .5, .5), approach a limiting spiral the way poly (n, n) does, as <span class="math"><em>n</em></span> goes to O? Explain why or why not. How about eqspi <span class="math">(<em>n</em>, <em>n</em>, <em>n</em> + 1)</span>? How about eqspi <span class="math">(<em>n</em>, <em>n</em>, <em>k</em><sup><em>n</em></sup>)</span>, <em>k</em> constant? [A]</p></li>
<li><p>What parameters describe equiangular spirals the way radius or curvature describes a circle? Relate these to the inputs of eqspi.</p></li>
<li><p><span class="math">[<em>D</em>]</span> Prove the assertion that any looping program which uses only s.forward, right, and grow has an eqspi skeleton, paralleling the results of section 1.3. What are the angle and the growth factor for the steps of the skeleton?</p></li>
</ol>
<h2 id="recursive-designs">Recursive Designs</h2>
<p>The branching models of section 2.3 could be described as recursive designs, because these figures contain subparts which are in some sense equivalent to the entire figure (for example, a branch is made up of branches). We’ve already run into two important considerations for writing turtle procedures to generate such designs: We need to include some kind of stop rule so that the process eventually stops generating more and more subiigures, and we need to keep track of the state of the turtle in designing the interface between part and subpart. ln particular, it helps to make each part state-transparent.</p>
<h3 id="nested-triangles">Nested Triangles</h3>
<div class="figure">
<img src="./fig2-23.png" alt="Figure drawn by nested.triangle" /><p class="caption">Figure drawn by nested.triangle</p>
</div>
<p>The nested triangle design shown in figure 2.23 illustrates these principles. The central observation is that the figure consists of a triangle plus a smaller copy of itself at each corner, just as the trees of the last section were forks plus smaller copies of themselves on each prong. Thus, we imagine the turtle drawing our figure as follows: At each of the vertices of the largest triangle, pause and construct a smaller figure of half the size, in the corner. The smaller triangles should follow the I same rules, drawing a still smaller triangle at each of their corners, and so on, and so on. Finally, we’ll stop generating subtriangles when the sides get very small. All together, the procedure is</p>
<pre><code>TO NESTED.TRIANGLE SIZE
   IF SIZE &lt; 10 THEN RETURN
   REPEAT 3
      NESTED.TRIANGLE SIZE / 2
      FORWARD SIZE
      RIGHT 120</code></pre>
<p>Notice that each nested.triangle(size) will be state-transparent as long as each nested.triangle(size/2) drawn in its corners satisfies that property. In turn, that state transparency depends on the state transparency of smaller and smaller nested.triangles until, when size is less than 10, the program stops, ensuring state transparency all the way back up the line. A simple variation on this program draws smaller figures outward from the corners:</p>
<pre><code>TO CORNER.TRI SIZE
   IF SIZE &lt; 10 THEN RETURN
   REPEAT 3
      FORWARD SIZE
      CORNER.TRI SIZE/2
      RIGHT 120</code></pre>
<p>Yet another way to interface a triangle to a recursive call to itself is to stop halfway through a side and put the recursive call there:</p>
<pre><code>TO OUTWARD.TRI SIZE
   IF SIZE &lt; 10 THEN RETURN
   REPEAT 3
      FORWARD SIZE / 2
      INSERT SIZE
      FORWARD SIZE / 2
      RIGHT 120

TO INSERT SIZE
   LEFT 120
   OUTWARD.TRI SIZE/2
   ; ensure state transparency of INSERT
   RIGHT 120</code></pre>
<div class="figure">
<img src="./fig2-24.png" alt="Shapes drawn by cornerpoly" /><p class="caption">Shapes drawn by cornerpoly</p>
</div>
<pre><code>TO NESTEDTRIANGLE (SIZE, LEVEL)
   IF LEVEL = 0 THEN RETURN
   REPEAT 3
      NESTEDTRIANGLE (SIZE/2, LEVEL - 1)
      FORWARD SIZE
      RIGHT 120</code></pre>
<p>These triangle procedures can be generalized to arbitrary poly figures. The only tricky part is to make sure we know how many sides to draw, say, as a function of the poly’s angle. As we saw in chapter 1, this can be done by accumulating total turning and stopping when the total turning is a multiple of <span class="math">360<sup> ∘ </sup></span>:</p>
<pre><code>TO CORNERPOLY (SIZE, ANGLE, TOTALTURN)
   IF SIZE &lt; 10 THEN RETURN
   REPEAT
      CORNERPOLYSTEP (SIZE, ANGLE)
      TOTALTURN &lt;- TOTALTURN + ANGLE
      UNTIL REMAINDER (TOTALTURN, 360) = 0

TO CORNERPOLYSTEP (SIZE, ANGLE)
   FORWARD SIZE
   CORNERPOLY (SIZE/2, - ANGLE, O)
   ; using - ANGLE &quot;symmetrizes&quot; the figure
   RIGHT ANGLE</code></pre>
<p>The cornerpoly procedure is invoked with the third input, totalturn, equal to zero. Figure 2.24 shows some samples drawn by this program. Although we’ve been using the side length as a stop rule for these designs, you might prefer to stop at a particular level of recursion. For example,</p>
<h3 id="snowflakes-and-other-curves">Snowflakes and Other Curves</h3>
<p>In some instances the effect of state transparency can be achieved although there is not true state transparency. In such cases, each procedure knows the state change of its subprocedures and hence knows what to do to compensate (if necessary). If the state change of the subprocedure is simple there are few disadvantages to this method, and if the state change is exactly what the main procedure needs to prepare for a next step this method can be advantageous. This strategy is illustrated by a program to draw the snowflake curve shown in figure 2.25. Think of this curve as a triangle in which each side is made up of four subsides, each subside is made up of four sub-subsides, <span class="math"><em>p</em></span> etc. Rather than making the procedure state-transparent, we’ll design each side to move the turtle forward a certain distance without changing the heading:</p>
<pre><code>TO SNOWFLAKE (SIZE, LEVEL)
   REPEAT 3
   SIDE (SIZE, LEVEL)
   RIGHT 120
   TO SIDE (SIZE, LEVEL)
   IF LEVEL = 0 THEN
      FORWARD SIZE
      RETURN
   SIDE (SIZE/3, LEVEL - 1)
   LEFT 60
   SIDE (SIZE/3, LEVEL - 1)
   RIGHT 120
   SIDE (SIZE/3, LEVEL - 1)
   LEFT G0
   SIDE (SIZE/3, LEVEL - 1)</code></pre>
<p>Until now the level = 0 process has been trivial, and has been statetransparent by virtue of doing nothing at all. Here the level = 0 action is crucial so that the level = 1 process gets the state change expected, forward(size). In fact, in the snowilake procedure no forward commands will be issued except when level = 0.</p>
<div class="figure">
<img src="./fig2-25.png" alt="The snowflake curve. (a) Recursive decomposition of a &quot;side.&quot; (b) Snowflake, level = 2. (c) Snowflake, level = 4" /><p class="caption">The snowflake curve. (a) Recursive decomposition of a &quot;side.&quot; (b) Snowflake, level = 2. (c) Snowflake, level = 4</p>
</div>
<p>Another related curve is the &quot;C curve&quot; shown in figure 2.26a. A level 0 C curve is just a line; a level <span class="math"><em>n</em></span> C curve consists of two level <span class="math"><em>n</em> − 1</span> C curves at right angles to each other, followed by a <span class="math">90<sup> ∘ </sup></span> turn to restore the heading:</p>
<pre><code>TO C (SIZE, LEVEL)
   IF LEVEL = 0 THEN
      FORWARD SIZE
      RETURN
   C (SIZE, LEVEL - 1)
   RIGHT 90
   C (SIZE, LEVEL - 1)
   LEFT 90</code></pre>
<div class="figure">
<img src="./fig2-26.png" alt="(a) C curve, level = 10. (b) Dragon curve, level = 11" /><p class="caption">(a) C curve, level = 10. (b) Dragon curve, level = 11</p>
</div>
<p>The &quot;dragon curve&quot; shown in figure 2.26b is similar to the C curve; however, there is only one <span class="math">90<sup> ∘ </sup></span> turn, and its direction changes from level to level. We can think of it as generated by a pair of procedures ldragon and rdragon specified as follows: A level <span class="math"><em>n</em></span> ldragon is made up of a level <span class="math"><em>n</em> − 1</span> ldragon and a level <span class="math"><em>n</em> − 1</span> rdragon with a left turn in between; a level <span class="math"><em>n</em></span> rdragon is made up of a level <span class="math"><em>n</em> − 1</span> ldragon and a level <span class="math"><em>n</em> − 1</span> rdragon with a right turn in between; a level 0 dragon is a line:</p>
<pre><code>TO LDRAGON (SIZE, LEVEL)
   IF LEVEL = 0 THEN
      FORWARD SIZE
      RETURN
   LDRAGON (SIZE, LEVEL - 1)
   LEFT 90
   RDRAG0N (SIZE, LEVEL - 1)
   TO RDRAGON (SIZE, LEVEL)
   IF LEVEL = 0 THEN
      FORWARD SIZE
      RETURN
   LDRAGON (SIZE, LEVEL - 1)
   RIGHT 90
   RDRAGON (SIZE, LEVEL - 1) </code></pre>
<h3 id="space-filling-design">Space-Filling Design</h3>
<p>Suppose we write a program that draws something inside a square. For the moment, we won’t care what the program does, but we will insist that the initial and final states of the turtle are related to the square as shown in figure 2.27a. Consider a new square that consists of nine smaller squares. We can use our simple program in each smaller square to produce a more complicated program winding through the new square (figure 2.27b). All we need is appropriate interfacing between subsquares. This more complicated program relates to the new square in exactly the same way that the simple program related to the first square, so we can continue this process. In the end we will have a square, consisting of nine smaller squares, each of which consists of still smaller squares, and I so on. The process is recursive, and can be implemented in the usual way (by writing the higher-level procedure in terms of the lower-level one). The interfaces between the various subfigures are shown in figure 2.27b. For a level 0 process, we can use the simplest possible way of entering and leaving a square, as assumed — forward(size). This gives the following procedure:</p>
<pre><code>TO FILL (SIZE, LEVEL)
   IF LEVEL = 0 THEN
      FORWARD SIZE
      RETURN
      ; side of small square is 1/3 side of large square
   FILL (SIZE / 3, LEVEL - 1)
   ; interface to next subfigure is LEFT 90
   LEFT 90
   FILL (SIZE / 3, LEVEL - 1)
   ; next three subfigures have RIGHT 90 as interface
   REPEAT 3
      RIGHT 90
      FILL (SIZE / 3, LEVEL - 1)
      ; next three have LEFT 90 as interface
   REPEAT 3
      LEFT 90
      FILL (SIZE / 3, LEVEL - 1)
      ; final subfigure has RIGHT 90 interface
   RIGHT 90
   FILL (SIZE / 3, LEVEL - 1)</code></pre>
<div class="figure">
<img src="./fig2-27.png" alt="The fill procedure. (a) Initial and final states for traversing a square. (b) Traversing the square, decomposed into traversing nine subsquares plus left-right interfacing. (c-e) The pattern drawn by fill at level = 1, 2, and 4." /><p class="caption">The fill procedure. (a) Initial and final states for traversing a square. (b) Traversing the square, decomposed into traversing nine subsquares plus left-right interfacing. (c-e) The pattern drawn by fill at level = 1, 2, and 4.</p>
</div>
<p>This fill procedure is an example of a space-filling design. lf we make level greater and greater, then the fill curve winds through the square in finer and finer subdivisions. For level very large, we could imagine fill as passing through every point of the square. fill, as written, draws a curve that intersects itself; however, it is possible to separate the nine subsquares with small interfaces to avoid intersection. (See exercise 5.) If done properly, this will not affect the space-filling property of the design.</p>
<div class="figure">
<img src="./fig2-28.png" alt="The Hilbert curve. (a) level=2 (b) level=3 (c) level=5 (d) Turtle &quot;traverses&quot; square by traversing each subsquare. (e) Decomposition of level n Hilbert curve into four level n - 1 curves together with interfaces. (f) Details of interfacing" /><p class="caption">The Hilbert curve. (a) level=2 (b) level=3 (c) level=5 (d) Turtle &quot;traverses&quot; square by traversing each subsquare. (e) Decomposition of level <span class="math"><em>n</em></span> Hilbert curve into four level <span class="math"><em>n</em> − 1</span> curves together with interfaces. (f) Details of interfacing</p>
</div>
<p>Perhaps the most famous space-filling design is the curve (shown in figure 2.28) invented by the German mathematician David Hilbert. As indicated in figure 2.28e, we can think of the level <span class="math"><em>n</em></span> Hilbert curve as made up of four level <span class="math"><em>n</em> − 1</span> Hilbert curves, joined by interfaces which are straight line segments. Another way to picture this is to imagine the square as divided into four subsquares. The Hilbert curve traverses the square by visiting each of the subsquares and placing the interfaces in between. (See figure 2.28d.)</p>
<p>In designing a program to draw the Hilbert curve we must be careful to keep track of how each level of the curve affects the state of the turtle. Assume that the turtle begins facing along the edge of the square that it traverses, and ends in the same direction. Then pasting together four level <span class="math"><em>n</em> − 1</span> curves to form the level n curve requires interface turns as shown in figure 2.28f. A second tricky point is that there are really two different level <span class="math"><em>n</em> − 1</span> Hilbert curves-one that traverses its square to the left and one that traverses to the right-and that the level <span class="math"><em>n</em></span> curve is made up of two of each parity. Finally, notice that the interfaces alone provide the state change assumed at each level, so we can let the level 0 curve be simply a point; then the interfaces in level 1 will provide the state change assumed by higher levels. The complete program consists of two procedures, lhilbert and rhilbert:</p>
<pre><code>TO LHILBERT (SIZE, LEVEL)
   IF LEVEL = 0 THEN RETURN
   ; rotate and draw first subcurve
   ; with opposite parity to big curve
   LEFT 90
   RHILBERT (SIZE, LEVEL - 1)
   ; interface to and draw second subcurve
   ; with same parity as big curve
   FORWARD SIZE
   RIGHT 90
   LHILBERT (SIZE, LEVEL - 1)
   ; third subcurve
   FORWARD SIZE
   LHILBERT (SIZE, LEVEL - 1)
   ; fourth subcurve
   RIGHT 90 \textsc{forward} SIZE
   RHILBERT (SIZE, LEVEL - 1)
   ; a final turn is needed to make the turtle
   ; end up facing outward from the large square
   LEFT 90</code></pre>
<p>The rhilbert procedure is the same, but with all the turns reversed:</p>
<pre><code>TO RHILBERT (SIZE, LEVEL)
   IF LEVEL = 0 THEN RETURN
   RIGHT 90
   LHILBERT (SIZE, LEVEL - 1)
   FORWARD SIZE
   LEFT 90
   RHILBERT (SIZE, LEVEL - 1)
   FORWARD SIZE
   RHILBERT (SIZE, LEVEL - 1)
   LEFT 90
   FORWARD SIZE
   LHILBERT (SIZE, LEVEL - 1)
   RIGHT 90</code></pre>
<p>We ean combine lhilbert and rhilbert into a single procedure by providing a third input, equal to <span class="math"> + 1</span> or <span class="math"> − 1</span>, whose sign is reversed to convert left turns to right turns:</p>
<pre><code>TO HILBERT (SIZE, LEVEL, PARITY)
   IF LEVEL = 0 THEN RETURN
   LEFT (PARITY * 90)
   HILBERT (SIZE, LEVEL - 1, - PARITY)
   FORWARD SIZE
   RIGHT (PARITY * 90)
   HILBERT (SIZE, LEVEL - 1 , PARITY)
   FORWARD SIZE
   HILBERT (SIZE, LEVEL - 1, PARITY)
   RIGHT (PARITY * 90)
   FORWARD SIZE
   HILBERT (SIZE, LEVEL - 1, - PARITY)
   LEFT (PARITY * 90)</code></pre>
<h4 id="exercises-for-section-3">Exercises for Section</h4>
<ol style="list-style-type: decimal">
<li><p><span class="math">[<em>P</em>]</span> Try the following variant of the nested-triangle procedure, which adds only one smaller triangle at each level connecting the midpoints of the larger triangle:</p>
<pre><code>TO NEST (SIZE, LEVEL)
   IF LEVEL = 0 THEN STOP
   FORWARD SIZE / 2
   SUBNEST (SIZE, LEVEL)
   FORWARD SIZE / 2
   RIGHT 120
   FORWARD SIZE
   RIGHT 120
   FORWARD SIZE
   RIGHT 120

TO SUBNEST (SIZE, LEVEL)
   RIGHT 60
   NEST (SIZE / 2, LEVEL - 1)
   LEFT GO</code></pre>
<p>Generalize this procedure to produce designs based on nested polys. [HA]</p></li>
<li><p>What is the length of the level n snowflake curve? How much area does it enclose? [HA]</p></li>
<li><p><span class="math">[<em>P</em>]</span> Write a procedure that generalizes the (triangular) snowflake curve to produce arbitrary &quot;polysnowflakes.&quot;</p></li>
<li><p><span class="math">[<em>D</em>]</span> What is the length of the level <span class="math"><em>n</em></span> Hilbert curve?</p></li>
<li><p><span class="math">[<em>P</em>]</span> The fill curve is not as elegant as it might be because it intersects itself. Add interfaces, in the same way that hilbert has them, to separate the squares a bit. (See figure 2.29.) Note that the net effect of the interfaces by themselves (including turning to set up for diagonals) is the state change assumed for each level of fill. This is the same as with the interfaces to hilbert, and makes it possible to allow the level 0 curve to be simply return. Try this possibility for fill as well.</p></li>
<li><p><span class="math">[<em>P</em>]</span> The Hilbert curve is constructed on the following model: (1) Walk along the side of a square, and imagine filling the square. (2) Divide the square into four subsquares. Construct a similar space-filling curve A based on dividing a triangle into four subtriangles.</p>
<div class="figure">
<img src="./fig2-29.png" alt="Interfaces to fill and resulting (level 2) design" /><p class="caption">Interfaces to fill and resulting (level 2) design</p>
</div></li>
<li><p><span class="math">[<em>P</em>]</span> Construct a space-filling curve on the Hilbert model, but based on dividing a square into nine subsquares.</p></li>
<li><p><span class="math">[<em>P</em><em>D</em>]</span> Write a procedure to draw the space-filling curve shown in figure 2.30. (This curve was invented by the Polish mathematician Wraclaw Sierpinski.)</p></li>
<li><p><span class="math">[<em>P</em>]</span> Invent some new space-filling designs.</p></li>
<li><p><span class="math">[<em>P</em>]</span> Can you build a recursive design like fill or hilbert, but based on entering the middle of the side of the square rather than the corner?</p></li>
<li><p><span class="math">[<em>P</em>]</span> How much does the fill curve depend on the particular level 0 step used? Does fill change its character if you use some more complicated level 0 step than forward(size)?</p></li>
<li><p><span class="math">[<em>P</em>]</span> Notice that in none of our recursive designs does the turtle have any representation of the curve except the program itself. On the other hand, by encoding turtle commands as letters, one can construct an explicit representation in the following way: Let F stand for forward SIZE, L for left 60, and R for right 120; then construct a string representing the side of a snowflake curve with the rules <br /><span class="math"><em>S</em><sub>0</sub> = <em>F</em></span><br /> <br /><span class="math"><em>S</em><sub><em>n</em></sub> = <em>S</em><sub><em>n</em> − 1</sub><em>L</em><em>S</em><sub><em>n</em> − 1</sub><em>R</em><em>S</em><sub><em>n</em> − 1</sub><em>L</em><em>S</em><sub><em>n</em> − 1</sub></span><br /></p>
<p>In fact a program to draw the side could be enacted as follows: Initialize <span class="math"><em>S</em> ← <em>F</em></span> ; apply the recursive step <span class="math"><em>S</em> ← <em>S</em><em>L</em><em>S</em><em>R</em><em>S</em><em>L</em><em>S</em></span> (juxtaposition denotes concatenation) <span class="math"><em>n</em></span> times; have the turtle interpret the resulting string. Try this with several known recursive designs, such as hilbert and snowflake. Now explore the possibilities of this &quot;word generation&quot; method by varying level 0, the recursive step, and the interpretation of letters. You may wish to add more variable symbols to the process, for example, <span class="math"><em>T</em> ← <em>S</em><em>R</em><em>S</em><em>L</em><em>S</em><em>R</em><em>S</em></span>.</p>
<div class="figure">
<img src="./fig2-30.png" alt="The Sierpinski curve" /><p class="caption">The Sierpinski curve</p>
</div></li>
<li><p><span class="math">[<em>P</em><em>D</em>]</span> All our recursive designs have maintained the constraint that turtle must not lift the pen. Thus, the recursive step in fill consisted of taking a certain walk through a square and then using that walk nine times in sequence to make a more complex walk through a square. But I we could just as easily imagine taking any design whatsoever in a square (not necessarily a walk through it) and gluing nine copies to make a larger square (without making sure the designs hook up simply). (See I figure 2.31a.) Of course the overall design will appear more impressive if some lines do &quot;accidentally&quot; hook up. This is like tiling a floor with more and more complex tiles. Varying the design on the level 0 tile together with the orientations for the tiles in the recursive step makes a fascinating artistic and mathematical exploration. To aid the exploration you may wish to implement the recursive gluing-together steps as programs that can take arbitrary design-drawing programs, including glued-together designs, as inputs. That way a level 3 recursive tile will look like glue1(glue2(glue3(shape1))). Figure 2.31b-e shows designs that can be made in this way. See if you can find the level 0 design in each.</p></li>
</ol>
